#!/usr/bin/perl

@reg8 = ("reg_al", "reg_cl", "reg_dl", "reg_bl",
         "reg_ah", "reg_ch", "reg_dh", "reg_bh");

@reg16 = ("reg_ax", "reg_cx", "reg_dx", "reg_bx",
          "reg_sp", "reg_bp", "reg_si", "reg_di");

@reg32 = ("reg_eax", "reg_ecx", "reg_edx", "reg_ebx",
          "reg_esp", "reg_ebp", "reg_esi", "reg_edi");

@eff_addr = (["reg_bx + reg_si",
              "reg_bx + reg_di",
	      "reg_bp + reg_si",
	      "reg_bp + reg_di",
	      "reg_si",
	      "reg_di",
	      "disp16",
	      "reg_bx"],
	     
	     ["reg_bx + reg_si + disp8",
	      "reg_bx + reg_di + disp8",
	      "reg_bp + reg_si + disp8",
	      "reg_bp + reg_di + disp8",
	      "reg_si + disp8",
	      "reg_di + disp8",
	      "reg_bp + disp8",
	      "reg_bx + disp8"],
	      
             ["reg_bx + reg_si + disp16",
              "reg_bx + reg_di + disp16",
              "reg_bp + reg_si + disp16",
              "reg_bp + reg_di + disp16",
              "reg_si + disp16",
              "reg_di + disp16",
              "reg_bp + disp16",
              "reg_bx + disp16"]);

sub gen_func()
{
	$name = shift;
	$b = shift;
	$noreg = shift;

	print "void $name()\n";

	print "{\n";
	print "\tswitch(fetchb())\n";
	print "\t{\n";

	for ($i = 0; $i < 256; $i++)
	{
		#       MODR/M BYTE
		#   
		#   7 6 | 5 4 3 | 2 1 0
		#   ----+-------+------
		#   MOD |  REG  |  R/M 
	
		$mod = (($i & 0xC0) >> 6);
		$reg = ($i >> 3) & 7;
		$rm  = ($i & 7);

		if ($b == 8) {
			$reg_str = $reg8[$reg];
		} elsif ($b == 16) {
			$reg_str = $reg16[$reg];
		} elsif ($b == 32) {
			$reg_str = $reg32[$reg];
		}
		
		$effaddr_prefix = "(";
		
		if ($mod < 3)
		{
			$effaddr_prefix = "(bit".$b."u *)(";
			
			if (($rm > 1) && ($rm < 4))
			{
				$effaddr_prefix .= "segreg[SS].ptr + ";
			} else { $effaddr_prefix .= "segreg[DS].ptr + "; }
			$effaddr_str = $eff_addr[$mod][$rm];
		} elsif ($b == 8)
		{
			$effaddr_str = "&".$reg8[$rm]."";
		} elsif ($b == 16)
		{
			$effaddr_str = "&".$reg16[$rm]."";
		} elsif ($b == 32)
		{
			$effaddr_str = "&".$reg32[$rm]."";
		}
		
		if ($noreg)
		{
		printf "\t\tcase 0x%.2X: opex = %s; rm$b = %s%s; break;\n",
			$i, $reg, $effaddr_prefix, $effaddr_str.")";
		} else {
		printf "\t\tcase 0x%.2X: r$b = &%s; rm$b = %s%s; break;\n",
		$i, $reg_str, $effaddr_prefix, $effaddr_str.")";
		}
	}
	print "\t}\n";
	print "}\n\n";
}

print <<EOL;
/*                                                                              
 * cpu_modrm.h                                                              
 *                                                                              
 * This program is free software; you can redistribute it and/or modify it      
 * under the terms of the GNU General Public License as published by the        
 * Free Software Foundation; either version 2, or (at your option) any          
 * later version.                                                               
 *                                                                              
 * This program is distributed in the hope that it will be useful, but          
 * WITHOUT ANY WARRANTY; without even the implied warranty of                   
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU            
 * General Public License for more details.                                     
 */

/* Generated by gen_modrm.pl */

#ifndef __CPU_MODRM_H
#define __CPU_MODRM_H

#define disp8 fetchb()
#define disp16 fetchw()

bit8u  *rm8;
bit16u *rm16;
bit32u *rm32;

bit8u  *r8;
bit16u *r16;
bit32u *r32;

bit8u   opex;

EOL

&gen_func("fetch_modrm8", 8, 0);
&gen_func("fetch_modrm16", 16, 0);

&gen_func("fetch_modrm8_opex", 8, 1);
&gen_func("fetch_modrm16_opex", 16, 1);

print "#endif /* __CPU_MODRM_H */\n";

